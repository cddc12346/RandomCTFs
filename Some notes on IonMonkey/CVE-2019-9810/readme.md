# Link and resources:

https://doar-e.github.io/blog/2019/06/17/a-journey-into-ionmonkey-root-causing-cve-2019-9810/#a-journey-into-ionmonkey-root-causing-cve-2019-9810

# Some important points:

1) js shell flag (--ion-warmup-threshold)

Helps IonMonkey identify hot code from cold code


# Simple analysis of Graph at AliasAnalysis Stage

## Code:
```
function x() {
    const a = [1,2,3,4];
    a.slice();
}

for(let Idx = 0; Idx < 0x2710; Idx++) {
    x();
}
```

## Graph:

### For loop
```
24		phi phi21:Int32 add72:Int32		Int32
25		constant magic optimized-out	MagicOptimizedOut
26		interruptcheck
27		constant 0x2710		Int32	---> Checks if Idx is less than 0x2710
28		compare phi24:Int32		constant27:Int32 lt		Bool
29		test compare28:Bool block4 block7
```

### Initializing array (const a = [1,2,3,4])

```
35	constant undefined	Undefined
36	constant undefined	Undefined
37	constant undefined	Undefined
38	constant magic uninitialized-lexical	MagicUninitializedLexical
39	constant object 26e6ded8f100 (Array)	Object
40	newarray constant39:Object	Object
41	constant 0x1	Int32		---> Element
42	constant 0x0	Int32		---> Array Index 
43	elements newarray40:Object	Elements
44	storeelement elements43:Elements constant42:Int32 constant41:Int32	---> StoreElement(index, element)
45	setinitializedlength elements43:Elements constant42:Int32			---> Set the length
```

### a.slice();
```
62	constant function slice at 26e6deda68c0	Object
63	constant function slice at 26e6deda68c0	Object
64	constant 0x0	Int32
65	elements newarray40:Object	Elements	memory 60	---> Getting the array object initialized at line 40
66	arraylength elements65:Elements	Int32				---> Getting the arrayt length
memory 60	67
arrayslice newarray40:Object constant64:Int32 arraylength66:Int32	Object	---> Slice element at index 0
```

## Alias Analysis

Reading some firefox source code, we can see the alias set for each of the operations.

?? What is the source code file?

For example, 

```
// Store a value to a dense array slots vector, set Element Alias
class MStoreElement
    : public MTernaryInstruction,
      public MStoreElementCommon,
      public MixPolicy<SingleObjectPolicy, NoFloatPolicy<2>>::Data {
  AliasSet getAliasSet() const override {
    return AliasSet::Store(AliasSet::Element);
  }
};

//Slice operation set 2 kinds of alias (Element and ObjectFields)
class MArraySlice : public MTernaryInstruction,
                    public MixPolicy<ObjectPolicy<0>, UnboxedInt32Policy<1>,
                                     UnboxedInt32Policy<2>>::Data {
  AliasSet getAliasSet() const override {
    return AliasSet::Store(AliasSet::Element | AliasSet::ObjectFields);
  }
};

// Load the array length from an elements header.
// Example of MArrayLength is used in slice
// 34 | arraylength elements33:Elements
class MArrayLength : public MUnaryInstruction, public NoTypePolicy::Data {
  AliasSet getAliasSet() const override {
    return AliasSet::Load(AliasSet::ObjectFields);
  }
};
```

Note the 2 different vectors in this phase (Store and Load)

In the alias analysis phase, there will be a summary on the operations and each kind of alias they are in.

These are contained in the stores and load vector.


```
//This reads as instructions 13, 18, 23, 28 and 35 are store instruction in the AliasSet::Element alias set.
stores[AliasSet::Element]      = [13, 18, 23, 28, 35]

stores[AliasSet::ObjectFields] = [14, 19, 24, 29, 35]
```

## So what exactly is done with those stores?

MElements is also a load vector.

When the algorithm encounters a load instruction, it walks the stores vector of the same AliasSet.

Eg. if load instruction alias AliasSet::Element, it will walk the stores[AliasSet::Element].

In order to establish this dependency link,

1) The instruction must have alias set that intersect, note this is done between the load and store vector.

Eg: AliasSet::Load(AliasSet::Any) intersects with AliasSet::Store(AliasSet::Element)

2) They must be object of the same typeset

** If a dependency is found between a load and store, it will be output when running the graph analysis. **

### Summary of alias analysis phase

1) Iterates over the instructions in the basic block and only cares about store and load instruction.

2) If instruction is a store, it gets added to a vector.

3) If instruction is a load, it is evaluated against every store in the vector to test for a dependency link.

4) A dependency link is established when both AliasSet and ObjectType intersects. 


# POC Analysis!!!

To compare patch and unpatched version, use the Alias-Sum flag.

In the patched version, we notice more dependencies mark with with array.slice operation.
```
[AliasSummaries]  loadslot30 marked depending on arrayslice27
[AliasSummaries]  elements32 marked depending on arrayslice27
[AliasSummaries]  initializedlength33 marked depending on arrayslice27
```

## Diving into the GVN phase

**Global Value Numbering phase** is like the v8 phase of removing and eliminating dead code.

Turning on the GVN flag, we can set all the dead code replaced or removed.

How does GVN determine to remove the second bounds check?
**congruentTo and foldTo**
1) Check if they have the same dependency
2) 

```
[GVN]       Replacing Elements32 with Elements17
[GVN]       Discarding dead Elements32

[GVN]       Replacing InitializedLength33 with InitializedLength18
[GVN]       Discarding dead InitializedLength33

[GVN]       Replacing BoundsCheck34 with BoundsCheck19
[GVN]       Discarding dead BoundsCheck34
```

We actually see many of the MIR code is being discarded.

## Tried running the POC but it is failing, or never trigger, Why!?

### Understanding the nursery chunk

Every js::NurseryChunk is 0x100000 bytes long (on x64) or 256 pages total 
and has effectively 0xffe8 usable bytes (the rest is metadata).

The biggest allocation request that can go through the Nursery is 1024 bytes long 
(defined by js::Nursery::MaxNurseryBufferSize).

If it exceeds this size usually the allocation is serviced from the jemalloc heap 
(which is the third heap in Firefox: Nursery, Tenured and jemalloc).


### Debugging the vuln

Putting anything in the function (Target) will introduce the bounds check..


### Writing a POC, some modifications required to corrupt the length of another array

```
for(let Idx = 0; Idx < 0x400; Idx++) {
	value = 0xCCCCCCCCCC + Idx;			//added this line so that the JIT function can take in a value larger than x32 arch
	Target(Snowflake, 0x70, value);
}

```

Learning Points:

1) Cannot use a normal array that is initialized like this (var array = [1.1, 1.2, 1.3]

2) Use a Uint32Array and set it to a **small** size, this will let it be located near the CorruptorArray

This is because when length is set to 0, the object is reallocated into a smaller memory area. New object is of length 0 and capacity 6. Hence, we can only use a small size spray object.

3) If you wanna to do a arbitrary write longer than 8 byte, JIT a float instead.

4) Putting anything in the JIT function will cause a different optimization although it can look totally irrelevant. By just putting Math.atan2(0), the second bounds check is not eliminated.



## Questions

?? ctor of array?

What is symbol.species?

?? Why must you call it within a array ctor?
?? Probably bounds check not eliminated. Dependency link happens? 
Compiler things other function can corrupt the length, but did not expect it to be within a array slice?












