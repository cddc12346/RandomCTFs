# Link and resources:

https://doar-e.github.io/blog/2019/06/17/a-journey-into-ionmonkey-root-causing-cve-2019-9810/#a-journey-into-ionmonkey-root-causing-cve-2019-9810

# Some important points:

1) js shell flag (--ion-warmup-threshold)

Helps IonMonkey identify hot code from cold code


# Simple analysis of Graph at AliasAnalysis Stage

python ghetto-iongraph.py --js-path js.exe --script-path exploit.js --overwrite

## Sample Code:
```
function x() {
    const a = [1,2,3,4];
    a.slice();
}

for(let Idx = 0; Idx < 0x2710; Idx++) {
    x();
}
```

## Output Graph:

### For loop
```
24		phi phi21:Int32 add72:Int32		Int32
25		constant magic optimized-out	MagicOptimizedOut
26		interruptcheck
27		constant 0x2710		Int32	---> Checks if Idx is less than 0x2710
28		compare phi24:Int32		constant27:Int32 lt		Bool
29		test compare28:Bool block4 block7
```

### Initializing array (const a = [1,2,3,4])

```
35	constant undefined	Undefined
36	constant undefined	Undefined
37	constant undefined	Undefined
38	constant magic uninitialized-lexical	MagicUninitializedLexical
39	constant object 26e6ded8f100 (Array)	Object
40	newarray constant39:Object	Object
41	constant 0x1	Int32		---> Element
42	constant 0x0	Int32		---> Array Index 
43	elements newarray40:Object	Elements
44	storeelement elements43:Elements constant42:Int32 constant41:Int32	---> StoreElement(index, element)
45	setinitializedlength elements43:Elements constant42:Int32			---> Set the length
```

### a.slice();
```
62	constant function slice at 26e6deda68c0	Object
63	constant function slice at 26e6deda68c0	Object
64	constant 0x0	Int32
65	elements newarray40:Object	Elements	memory 60	---> Getting the array object initialized at line 40
66	arraylength elements65:Elements	Int32				---> Getting the arrayt length
memory 60	67
arrayslice newarray40:Object constant64:Int32 arraylength66:Int32	Object	---> Slice element at index 0
```

## Understanding the Alias Analysis phase

Reading some firefox source code, we can see the alias set for each of the operations.

Each operation (MStoreElement, MElement, MArraySlice, etc) has its own alias set. They can be either a Store or Load vector.

For example, 

```
// Store a value to a dense array slots vector, set Element Alias
// This operation is in the Store vector with an Element AliasSet 
class MStoreElement
    : public MTernaryInstruction,
      public MStoreElementCommon,
      public MixPolicy<SingleObjectPolicy, NoFloatPolicy<2>>::Data {
  AliasSet getAliasSet() const override {
    return AliasSet::Store(AliasSet::Element);
  }
};

// Slice operation set 2 kinds of alias (Element and ObjectFields)
// This operation is in the Store vector with an Element AliasSet AND ObjectFields AliasSet
class MArraySlice : public MTernaryInstruction,
                    public MixPolicy<ObjectPolicy<0>, UnboxedInt32Policy<1>,
                                     UnboxedInt32Policy<2>>::Data {
  AliasSet getAliasSet() const override {
    return AliasSet::Store(AliasSet::Element | AliasSet::ObjectFields);
  }
};

// Load the array length from an elements header.
// Example of MArrayLength is used in slice
// 34 | arraylength elements33:Elements
// This operation is in the Load vector with an ObjectField AliasSet
class MArrayLength : public MUnaryInstruction, public NoTypePolicy::Data {
  AliasSet getAliasSet() const override {
    return AliasSet::Load(AliasSet::ObjectFields);
  }
};
```

**Note the 2 different vectors in this phase (Store and Load)**

By setting the alias-sum flag, in the alias analysis phase, there will be a summary on the operations and each kind of alias they are in.

```
//This reads as instructions 13, 18, 23, 28 and 35 are store instruction in the AliasSet::Element alias set.
stores[AliasSet::Element]      = [13, 18, 23, 28, 35]

stores[AliasSet::ObjectFields] = [14, 19, 24, 29, 35]
```

## So what exactly is done with those stores?

When the algorithm encounters a load instruction such as MElement, it walks the stores vector of the same AliasSet and tries to establish dependency links.

Eg. if load instruction alias AliasSet::Element, it will walk the stores[AliasSet::Element].

In order to establish this dependency link,

1) The instruction must have alias set that intersect, note this is done between the load and store vector.

Eg: AliasSet::Load(AliasSet::Any) intersects with AliasSet::Store(AliasSet::Element)

2) They must be object of the same typeset

**If a dependency is found between a load and store, it will be output on cmd prompt when running the graph analysis.**

## Summary of alias analysis phase

1) Iterates over the instructions in the basic block and only cares about store and load instruction.

2) If instruction is a store, it gets added to a vector.

3) If instruction is a load, it is evaluated against every store in the vector to test for a dependency link.

4) A dependency link is established when both AliasSet and ObjectType intersects. 


# POC Analysis!!!

To compare patch and unpatched version, use the **Alias-Sum** flag.

In the patched version, we notice more dependencies mark with array.slice operation.
```
[AliasSummaries]  loadslot30 marked depending on arrayslice27
[AliasSummaries]  elements32 marked depending on arrayslice27
[AliasSummaries]  initializedlength33 marked depending on arrayslice27
```

## Diving into the GVN phase

I would suggest reading the original link as it gives the examples.

**Global Value Numbering phase** is like the v8 phase of removing and eliminating dead code.

Turning on the GVN flag, we can set all the dead code replaced or removed.

How does GVN determine to remove the second bounds check?

**congruentTo and foldTo**

```
[GVN]       Replacing Elements32 with Elements17
[GVN]       Discarding dead Elements32

[GVN]       Replacing InitializedLength33 with InitializedLength18
[GVN]       Discarding dead InitializedLength33

[GVN]       Replacing BoundsCheck34 with BoundsCheck19
[GVN]       Discarding dead BoundsCheck34
```

We actually see that many of the MIR code is being discarded.

## Tried running the POC but it is failing, or never trigger, Why!?

1) If it never overwrites a valid pointer, it wouldnt crash.

### Understanding the nursery chunk

Every js::NurseryChunk is 0x100000 bytes long (on x64) or 256 pages total 
and has effectively 0xffe8 usable bytes (the rest is metadata).

The biggest allocation request that can go through the Nursery is 1024 bytes long 
(defined by js::Nursery::MaxNurseryBufferSize).

If it exceeds this size usually the allocation is serviced from the jemalloc heap 
(which is the third heap in Firefox: Nursery, Tenured and jemalloc).


### Debugging the vuln

Putting anything in the function (Target) will re-introduce the second bounds check..


### Writing a POC, some modifications required to corrupt the length of another array

```
for(let Idx = 0; Idx < 0x400; Idx++) {
	value = 0xCCCCCCCCCC + Idx;			//added this line so that the JIT function can take in a value larger than x32 arch
	Target(Snowflake, 0x70, value);
}

```

Learning Points:

1) Cannot use a normal array that is initialized like this (var array = [1.1, 1.2, 1.3]

2) Use a Uint32Array and set it to a **small** size, this will let it be located near the CorruptorArray

This is because when length is set to 0, the object is reallocated into a smaller memory area. New object is of length 0 and capacity 6. Hence, we can only use a small size spray object.

3) If you wanna to do a arbitrary write longer than 8 byte, JIT a float instead.

4) Putting anything in the JIT function will cause a different optimization although it can look totally irrelevant. By just putting Math.atan2(0), the second bounds check is not eliminated.



## Questions

?? ctor of array?

What is symbol.species?

?? Why must you call it within a array ctor?
?? Probably bounds check not eliminated. Dependency link happens? 
Compiler things other function can corrupt the length, but did not expect it to be within a array slice?



## Trying to answer 0verClok questions!

Why does AccessArray(10) triggers a bailout?

```
let Arr = null;
function AccessArray(Idx) {
    Arr[Idx] = 0xaaaaaaaa;
}

Arr = new Array(0x100);
for(let Idx = 0; Idx < 0x400; Idx++) {
    AccessArray(1);
}

AccessArray(10);
```

Running the code, we see this output.

```
[IonBailouts] Took bailout! Snapshot offset: 11
[IonBailouts] Bounds check failure exploit.js:2:0, inlined into exploit.js:2:0
```

Hmm... there is a bounds check failure in AccessArray when accessing the 10th element. 

My guess is because the JIT function always access the constant 1 index.

This index becomes a constant in the JIT function, thus accessing any element below it after will not bailout from the bounds check.

Bailout happens when indexing any element above the JIT parameter.

However, I cannot see it on the graph. If anyone finds out, please ping me at twitter (@n00bsh1t)






# Interesting findings 101





